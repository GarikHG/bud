/**
 * @roots/bud v.2.0.0-next.0 {@link https://roots.io/bud}
 *
 * A friendly build tool to help manage your project assets.
 *
 * Issues? {@link https://github.com/roots/bud/issues}
 *
 * Consider funding our work 🙏🏽 {@link https://github.com/sponsors/roots}
 *
 * @copyright 2020 Roots {@link https://roots.io}
 * @license MIT
 */
import { useState, useEffect } from 'react';
import { useProgress } from './useProgress.js';
import { useHotSyncServer } from './useHotSyncServer.js';

/**
 * Hook: useWebpack
 *
 * @prop {Bud} bud
 */

const useWebpack = bud => {
  /**
   * Query bud for mode settings.
   */
  const [hot] = useState(bud.features.enabled('hot'));
  const [watch] = useState(bud.features.enabled('watch'));
  /**
   * Webpack callback
   *
   * This is fired when webpack finishes each round of compilation.
   *
   * This callback is not utilized when running in hot mode. That is
   * handled in the useHotSyncServer hook and is managed by webpack
   * dev server middleware.
   */

  const webpackCallback = (err, stats) => {
    const results = {};
    /**
     * Add webpack compiler errors to state.
     */

    if (err) {
      results.error = err;
      bud.logger.error({
        name: 'bud.compiler',
        err
      }, 'webpack compiler callback generated build errors');
    }
    /**
     * Add webpack compiler stats to state
     */


    if (stats) {
      results.stats = stats.toJson({
        version: true,
        hash: true,
        time: true,
        assets: true,
        errors: true,
        warnings: true,
        chunks: false,
        modules: false,
        entrypoints: false,
        assetsByChunkName: false,
        logging: false,
        children: false,
        namedChunkGroups: false
      });
      bud.logger.info({
        name: 'bud.compiler',
        assets: results.stats.assets.map(asset => asset.name)
      }, 'webpack compiler callback generated prototypal build stats');
    }

    setBuild(results);
  };
  /**
   * Add progress plugin to state.
   */


  const {
    progressPlugin,
    percentage,
    message
  } = useProgress(bud);
  const [progressPluginApplied, setProgressPluginApplied] = useState(null);
  useEffect(() => {
    if (progressPlugin) {
      progressPlugin.apply(bud.compiler);
      setProgressPluginApplied(true);
      bud.logger.info({
        name: 'bud.compiler'
      }, 'progress plugin applied');
    }
  }, [progressPlugin, bud]);
  /**
   * Run webpack compiler and log output to state.
   */

  const [build, setBuild] = useState({});
  const [webpackRunning, setWebpackRunning] = useState(null);
  useEffect(() => {
    if (progressPluginApplied && !webpackRunning) {
      /** Hot builds are handled by WDS middleware */
      if (hot) {
        return;
      }
      /**
       * Run compiler in watch mode if bud watch feature is enabled.
       */


      if (watch) {
        bud.logger.info({
          name: 'bud.compiler',
          hot,
          watch,
          progressPluginApplied,
          webpackRunning
        }, 'starting compiler in watch mode');
        bud.compiler.watch({}, webpackCallback);
        /**
         * Otherwise, run the vanilla compiler.
         */
      } else {
        bud.logger.info({
          name: 'bud.compiler',
          hot,
          watch,
          progressPluginApplied,
          webpackRunning
        }, 'starting compiler in run mode');
        bud.compiler.run(webpackCallback);
      }

      setWebpackRunning(true);
    }
  }, [progressPluginApplied, webpackRunning, hot, watch, bud]);
  /**
   * Assets are generated by webpack's core compiler when not in hot mode.
   * This is set to the build state variable above.
   *
   * When in hot mode assets are generated by WDS middleware slotted onto
   * BrowserSync. This is set to the devStats state variable
   * in the useHotSyncServer hook. That call happens below.
   *
   * Only one of them will run at a time.
   */

  /**
   * Stats state variables consumed by application.
   */

  const [assets, setAssets] = useState([]);
  const [warnings, setWarnings] = useState([]);
  const [errors, setErrors] = useState([]);
  const [hash, setHash] = useState(null);
  const [time, setTime] = useState(null);
  const [hotSyncServer, devStats] = useHotSyncServer(bud);
  /**
   * Assets generated by webpack compiler.run or webpack compiler.watch
   */

  useEffect(() => {
    var _build$stats, _build$stats2, _build$stats3, _build$stats4, _build$stats5;

    (build === null || build === void 0 ? void 0 : (_build$stats = build.stats) === null || _build$stats === void 0 ? void 0 : _build$stats.assets) && setAssets(build.stats.assets);
    (build === null || build === void 0 ? void 0 : (_build$stats2 = build.stats) === null || _build$stats2 === void 0 ? void 0 : _build$stats2.warnings) && setWarnings(build.stats.warnings);
    (build === null || build === void 0 ? void 0 : (_build$stats3 = build.stats) === null || _build$stats3 === void 0 ? void 0 : _build$stats3.errors) && setErrors(build.stats.errors);
    (build === null || build === void 0 ? void 0 : (_build$stats4 = build.stats) === null || _build$stats4 === void 0 ? void 0 : _build$stats4.hash) && setHash(build.stats.hash);
    (build === null || build === void 0 ? void 0 : (_build$stats5 = build.stats) === null || _build$stats5 === void 0 ? void 0 : _build$stats5.time) && setTime(build.stats.time);
  }, [build]);
  /**
   * Assets generated by WDS middleware (hot builds)
   */

  useEffect(() => {
    (devStats === null || devStats === void 0 ? void 0 : devStats.assets) && setAssets(devStats.assets);
    (devStats === null || devStats === void 0 ? void 0 : devStats.warnings) && setWarnings(devStats.warnings);
    (devStats === null || devStats === void 0 ? void 0 : devStats.errors) && setErrors(devStats.errors);
    (devStats === null || devStats === void 0 ? void 0 : devStats.hash) && setHash(devStats.hash);
    (devStats === null || devStats === void 0 ? void 0 : devStats.time) && setTime(devStats.time);
  }, [devStats]);
  /**
   * For convenience set a boolean conditional state variable
   * for tracked build stats. This affords not having to
   * litter length > 0 checks throughout the rest of the application.
   */

  const [hasAssets, setHasAssets] = useState(false);
  useEffect(() => {
    if (assets && assets.length > 0) {
      setHasAssets(true);
      bud.logger.info({
        name: 'bud.compiler',
        assets: assets.map(asset => asset.name)
      }, 'new state: assets');
    }
  }, [assets]);
  const [hasWarnings, setHasWarnings] = useState(false);
  useEffect(() => {
    if (warnings && warnings.length > 0) {
      setHasWarnings(true);
      bud.logger.info({
        name: 'bud.compiler',
        warnings: warnings.map(asset => asset.name)
      }, 'new state: warnings');
    }
  }, [warnings]);
  const [hasErrors, setHasErrors] = useState(false);
  useEffect(() => {
    if (errors && errors.length > 0) {
      setHasErrors(true);
      bud.logger.info({
        name: 'bud.compiler',
        errors: errors.map(asset => asset.name)
      }, 'new state: errors');
    }
  }, [errors]);
  const [hasHash, setHasHash] = useState(false);
  useEffect(() => {
    if (hash) {
      setHasHash(true);
      bud.logger.info({
        name: 'bud.compiler',
        hash
      }, 'new state: hash');
    }
  }, [hash]);
  const [hasTime, setHasTime] = useState(false);
  useEffect(() => {
    if (time) {
      setHasTime(true);
      bud.logger.info({
        name: 'bud.compiler',
        payload: time
      }, 'new state: time');
    }
  }, [time]);
  /**
   * Build needs to have assets/errors present
   * before returning true for build.done even if the percentage is 100%.
   * This is because progress finishes slightly before the assets
   * finish processing into state and so only checking for % it is common
   * to end up with no asset logs rendered to the CLI before the application
   * exits.
   */

  const done = percentage === 1 && (hasAssets || hasErrors);
  const success = percentage === 1 && hasAssets && !hasErrors;
  /**
   * Return state to consumers.
   */

  return {
    assets,
    hasAssets,
    errors,
    hasErrors,
    hash,
    hasHash,
    time,
    hasTime,
    warnings,
    hasWarnings,
    percentage,
    done,
    success,
    message,
    hotSyncServer
  };
};

export { useWebpack };
