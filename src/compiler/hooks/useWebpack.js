import {useState, useEffect} from 'react'
import {useProgress} from './useProgress'
import {useHotSyncServer} from './useHotSyncServer'

/**
 * Hook: useWebpack
 *
 * @prop {Bud} bud
 */
const useWebpack = bud => {
  /**
   * Query bud for mode settings.
   */
  const [hot] = useState(bud.features.enabled('hot'))
  const [watch] = useState(bud.features.enabled('watch'))

  /**
   * Webpack callback
   *
   * This is fired when webpack finishes each round of compilation.
   *
   * This callback is not utilized when running in hot mode. That is
   * handled in the useHotSyncServer hook and is managed by webpack
   * dev server middleware.
   */
  const webpackCallback = (err, stats) => {
    const results = {}

    /**
     * Add webpack compiler errors to state.
     */
    if (err) {
      results.error = err

      bud.logger.error(
        {name: 'bud.compiler', err},
        'webpack compiler callback generated build errors',
      )
    }

    /**
     * Add webpack compiler stats to state
     */
    if (stats) {
      results.stats = stats.toJson({
        version: true,
        hash: true,
        time: true,
        assets: true,
        errors: true,
        warnings: true,
        chunks: false,
        modules: false,
        entrypoints: false,
        assetsByChunkName: false,
        logging: false,
        children: false,
        namedChunkGroups: false,
      })

      bud.logger.info(
        {
          name: 'bud.compiler',
          assets: results.stats.assets.map(asset => asset.name),
        },
        'webpack compiler callback generated prototypal build stats',
      )
    }

    setBuild(results)
  }

  /**
   * Add progress plugin to state.
   */
  const {progressPlugin, percentage, message} = useProgress(bud)
  const [progressPluginApplied, setProgressPluginApplied] = useState(null)
  useEffect(() => {
    if (progressPlugin) {
      progressPlugin.apply(bud.compiler)
      setProgressPluginApplied(true)

      bud.logger.info({name: 'bud.compiler'}, 'progress plugin applied')
    }
  }, [progressPlugin, bud])

  /**
   * Run webpack compiler and log output to state.
   */
  const [build, setBuild] = useState({})
  const [webpackRunning, setWebpackRunning] = useState(null)
  useEffect(() => {
    if (progressPluginApplied && !webpackRunning) {
      /** Hot builds are handled by WDS middleware */
      if (hot) {
        return
      }

      /**
       * Run compiler in watch mode if bud watch feature is enabled.
       */
      if (watch) {
        bud.logger.info(
          {
            name: 'bud.compiler',
            hot,
            watch,
            progressPluginApplied,
            webpackRunning,
          },
          'starting compiler in watch mode',
        )

        bud.compiler.watch({}, webpackCallback)

        /**
         * Otherwise, run the vanilla compiler.
         */
      } else {
        bud.logger.info(
          {
            name: 'bud.compiler',
            hot,
            watch,
            progressPluginApplied,
            webpackRunning,
          },
          'starting compiler in run mode',
        )

        bud.compiler.run(webpackCallback)
      }

      setWebpackRunning(true)
    }
  }, [progressPluginApplied, webpackRunning, hot, watch, bud])

  /**
   * Assets are generated by webpack's core compiler when not in hot mode.
   * This is set to the build state variable above.
   *
   * When in hot mode assets are generated by WDS middleware slotted onto
   * BrowserSync. This is set to the devStats state variable
   * in the useHotSyncServer hook. That call happens below.
   *
   * Only one of them will run at a time.
   */

  /**
   * Stats state variables consumed by application.
   */
  const [assets, setAssets] = useState([])
  const [warnings, setWarnings] = useState([])
  const [errors, setErrors] = useState([])
  const [hash, setHash] = useState(null)
  const [time, setTime] = useState(null)
  const [hotSyncServer, devStats] = useHotSyncServer(bud, webpackCallback)

  /**
   * Assets generated by webpack compiler.run or webpack compiler.watch
   */
  useEffect(() => {
    build?.stats?.assets && setAssets(build.stats.assets)
    build?.stats?.warnings && setWarnings(build.stats.warnings)
    build?.stats?.errors && setErrors(build.stats.errors)
    build?.stats?.hash && setHash(build.stats.hash)
    build?.stats?.time && setTime(build.stats.time)
  }, [build])

  /**
   * Assets generated by WDS middleware (hot builds)
   */
  useEffect(() => {
    devStats?.assets && setAssets(devStats.assets)
    devStats?.warnings && setWarnings(devStats.warnings)
    devStats?.errors && setErrors(devStats.errors)
    devStats?.hash && setHash(devStats.hash)
    devStats?.time && setTime(devStats.time)
  }, [devStats])

  /**
   * For convenience set a boolean conditional state variable
   * for tracked build stats. This affords not having to
   * litter length > 0 checks throughout the rest of the application.
   */
  const [hasAssets, setHasAssets] = useState(false)
  useEffect(() => {
    if (assets && assets.length > 0) {
      setHasAssets(true)
      bud.logger.info(
        {name: 'bud.compiler', assets: assets.map(asset => asset.name)},
        'new state: assets',
      )
    }
  }, [assets])

  const [hasWarnings, setHasWarnings] = useState(false)
  useEffect(() => {
    if (warnings && warnings.length > 0) {
      setHasWarnings(true)
      bud.logger.info(
        {name: 'bud.compiler', warnings: warnings.map(asset => asset.name)},
        'new state: warnings',
      )
    }
  }, [warnings])

  const [hasErrors, setHasErrors] = useState(false)
  useEffect(() => {
    if (errors && errors.length > 0) {
      setHasErrors(true)
      bud.logger.info(
        {name: 'bud.compiler', errors: errors.map(asset => asset.name)},
        'new state: errors',
      )
    }
  }, [errors])

  const [hasHash, setHasHash] = useState(false)
  useEffect(() => {
    if (hash) {
      setHasHash(true)
      bud.logger.info({name: 'bud.compiler', hash}, 'new state: hash')
    }
  }, [hash])

  const [hasTime, setHasTime] = useState(false)
  useEffect(() => {
    if (time) {
      setHasTime(true)
      bud.logger.info({name: 'bud.compiler', payload: time}, 'new state: time')
    }
  }, [time])

  /**
   * Build needs to have assets/errors present
   * before returning true for build.done even if the percentage is 100%.
   * This is because progress finishes slightly before the assets
   * finish processing into state and so only checking for % it is common
   * to end up with no asset logs rendered to the CLI before the application
   * exits.
   */
  const done = percentage === 1 && (hasAssets || hasErrors)
  const success = percentage === 1 && hasAssets && !hasErrors

  /**
   * Return state to consumers.
   */
  return {
    assets,
    hasAssets,
    errors,
    hasErrors,
    hash,
    hasHash,
    time,
    hasTime,
    warnings,
    hasWarnings,
    percentage,
    done,
    success,
    message,
    hotSyncServer,
  }
}

export {useWebpack}
